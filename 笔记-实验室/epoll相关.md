#### LT和ET的区别



首先都说ET比LT高效那么高效在哪些地方？

说是ET模式很大程度上降低了同一个epoll事件被重复触发的次数因此效率比较高 。。。说的其实不清不楚



在用户态调用recv的时候 如果有数据到达内核缓冲区会怎么样？

读出的是recv调用当时的内核缓冲区的数据还是说在读内核缓冲区的时候 还可以往内核缓冲区写？

肯定不是单缓冲区吧！！！





#### 对于 send和recv的深入理解

**概念上容易疑惑的地方**

  　　1. TCP协议本身是为了保证可靠传输,并不等于应用程序用tcp发送数据就一定是可靠的，必须要容错；
        　　2. send（）和recv（）没有固定的对应关系，不定数目的send()可以触发不定数目的recv（），这话不专业，但是还是必须说一下，初学者容易疑惑；
              　　3. 关键点，send（）只负责拷贝，拷贝到内核就返回，我通篇在说拷贝完返回，很多文章中说send（）在成功发送数据后返回，成功发送是说发出去的东西被ACK确认过。send（）只拷贝，不会等ACK；
                    　　4. 此次send（）调用所触发的程序错误，可能会在本次返回，也可能在下次调用网络IO函数的时候被返回。



#### c++ 对象的内存布局  

它们是按照虚函数表指针、父类成员变量、子类成员变量在内存中的顺序在内存中存放的。

这个顺序由编译器决定，我在LINUX用g++验证过，是这个顺序。



在C++中对象的实现中，成员函数和成员变量是分离的 
所以我们所谈到的非静态成员函数其实只是一个普通的函数（不过被编译器所隐藏，必须绑定到特定的对象上才能执行） 
静态成员函数实际上就真的就是一个普通的函数，独立于整个对象之外，不过被编译器加上了一堆修饰避免重命名，和对象无关 

普通非静态成员函数的实现是通过传入this指针的方式去绑定到特定的对象上，然后执行特化的操作



对象的普通函数其实是这样的如果是不依赖于对象的成员那么就是一个独立于对象的普通函数 空指针也可以调用 因为知道对象的静态类型 就知道这个函数的代码，而且代码当中又不需要使用到成员变量 就不会传入this指针 所以这是编译器做的优化。如果函数内部显示的使用到了this指针那么就会被传入 那么如果使用到了但是使用的是空指针调用会出现什么问题？？？

我这边可以明确一个东西，调用非虚函数的普通函数的过程就是通过静态类型的信息去获取你有没有这个权限或者能力或者就是有没有相应的这个名称的方法，如果都满足那么就看这个传参是不是满足，如果满足就找最合适的如果不满足就按照一定的规则去做类型转换看满不满足。那么编译器作了哪些事情那就是一些细节的考量。

实验一个问题就是 使用某一个类型的空指针去获取该类型对象的一个成员会发生什么事情？ 是会coredump还是发生什么？肯定是直接崩溃  别想了





